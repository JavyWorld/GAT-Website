ðŸ—ï¸ Proyecto GAT-Web (Guild Activity Tracker Web Platform)
1. VisiÃ³n General de la Arquitectura
El sistema se divide en dos componentes desacoplados:

GAT-Client (Python Uploader): Un "agente ligero" que corre en la PC del usuario.

GAT-Server (La Nube): Una plataforma web completa que procesa, almacena y visualiza los datos.

2. El Agente Local (Python Uploader)
FunciÃ³n: "Mensajero ciego". No piensa, solo envÃ­a.

Input: Monitoriza el archivo GuildActivityTracker.lua en la carpeta de WoW.

Logic:

Detecta cambios en el archivo.

Lee el contenido crudo.

Lo comprime (gzip) para ahorrar ancho de banda.

AcciÃ³n: EnvÃ­a una peticiÃ³n POST segura a https://tu-web.com/api/upload.

Seguridad: Usa un API_KEY Ãºnica generada en la web para autenticar quÃ© guild estÃ¡ enviando datos.

3. El Backend (Servidor & API)
TecnologÃ­a Recomendada: Python (FastAPI o Django) o Node.js (NestJS). Dado que ya tenemos lÃ³gica en Python, recomiendo FastAPI por su velocidad y manejo asÃ­ncrono.

Base de Datos (PostgreSQL)
Ya no usamos hojas de cÃ¡lculo planas. Usaremos un modelo relacional robusto:

Table Guilds: ConfiguraciÃ³n de la guild, regiÃ³n, reino, API Keys de WarcraftLogs/Raider.IO.

Table Players: ID Ãºnico, Nombre, Reino, Clase, Raza, Avatar URL, is_active.

Table Snapshots (Activity Logs): Timestamp, Total Online, Lista de IDs conectados (JSONB).

Table ChatLogs: Historial de mensajes (relacionado con Player ID).

Table MythicScores: Historial de puntuaciÃ³n por temporada (para ver progreso).

Table RaidParses (Nuevo): Datos traÃ­dos de WarcraftLogs (DPS/HPS por boss).

Servicios del Backend (Workers)
Estos son procesos que corren en segundo plano (usando Celery o Redis Queue):

Ingestion Worker: Recibe el JSON del Addon, valida la estructura y actualiza la tabla Players (marca nuevos como activos, viejos como inactivos).

RaiderIO Worker: Cron Job cada 60 minutos. Recorre la tabla Players activa y actualiza sus scores, fotos y specs.

WarcraftLogs Worker (Nuevo): Consulta la API de WLogs buscando el Ãºltimo reporte de la guild y asocia el rendimiento (Parse %) a cada jugador.

Discord Bot Service: Escucha eventos (ej: "Nuevo rÃ©cord de M+") y envÃ­a alertas al canal de Discord.

4. El Frontend (La PÃ¡gina Web)
TecnologÃ­a: React.js o Next.js + Tailwind CSS + Recharts (para grÃ¡ficas). EstÃ©tica: "Dark Mode" estilo Gaming/Cyberpunk (Colores de clase de WoW, fondos oscuros, neones).

Mapa del Sitio (Sitemap) y Funcionalidades
A. ðŸ  Home / Dashboard (Centro de Mando)
Resumen KPI: Tarjetas grandes con "Miembros Activos", "Online Ahora", "Score Promedio de Guild".

Heatmap de Actividad: El grÃ¡fico de colores (DÃ­a vs Hora) que diseÃ±amos, pero interactivo (al pasar el mouse ves detalles).

Actividad Reciente: Un feed estilo red social: "Javier subiÃ³ a 2500 IO", "La Guild matÃ³ a Sarkareth MÃ­tico".

B. âš”ï¸ Roster & Members (La Lista Definitiva)
Tabla Avanzada: Lista de todos los jugadores con columnas ordenables (Rango, Clase, Score, iLvl, Parses).

Filtros Potentes: "Ver solo Healers", "Ver solo > 2000 IO", "Ocultar Inactivos".

Estado: Indicador visual (punto verde/gris) de si estÃ¡ Online en el juego (basado en el Ãºltimo snapshot).

C. ðŸ‘¤ Player Profile (Perfil del Jugador)
Al hacer clic en un nombre en el Roster, te lleva aquÃ­.

Header: Render 3D del personaje (usando la API de Blizzard o Raider.IO) y su fondo de clase.

Activity Graph: GrÃ¡fica lineal de sus mensajes/actividad en el Ãºltimo mes.

Progreso M+: Historial de sus mejores llaves y grÃ¡fica de cÃ³mo ha subido su IO semana a semana.

WarcraftLogs Card: Sus mejores "Parses" (DesempeÃ±o % en Raid) mostrados con colores (Gris, Verde, Azul, Violeta, Naranja).

D. ðŸ† Mythic+ Leaderboard
Ranking Competitivo: Top 10 de la guild.

Best Keys: Muestra quÃ© mazmorras tiene hechas en +20, +15, etc.

Team Builder (Nuevo): Una herramienta donde seleccionas 5 jugadores y la web calcula el "Score Promedio del Grupo" y si tienen los buffs necesarios (BL, Battle Rez).

E. ðŸ“Š Raid Analytics (IntegraciÃ³n WarcraftLogs)
Progreso de Guild: QuÃ© bosses han muerto y en quÃ© dificultad.

Asistencia: QuiÃ©nes han venido a las raids las Ãºltimas 4 semanas (calculado cruzando snapshots del addon durante horas de raid).

F. âš™ï¸ Admin Panel (Solo para ti)
GestiÃ³n de Usuarios: Dar permisos a otros oficiales para ver datos sensibles.

API Keys: Donde pegas tus claves de Raider.IO y WLogs.

AuditorÃ­a: Log de quiÃ©n subiÃ³ datos y cuÃ¡ndo.

BotÃ³n de PÃ¡nico "The Purge": Ejecutar limpieza manual de ex-miembros.

5. Integraciones Nuevas (APIs Externas)
Blizzard OAuth: Permitir que los miembros se logueen en tu web con su cuenta de Battle.net. Esto verifica que realmente son ellos.

WarcraftLogs API:

Traer los "Parses" (Rendimiento) para saber no solo quiÃ©n habla, sino quiÃ©n juega bien.

Traer el iLvl (Nivel de objeto) exacto y equipamiento.

Discord Webhooks:

NotificaciÃ³n automÃ¡tica: "Â¡GAT Reporte! 25 miembros conectados. RÃ©cord del dÃ­a."

NotificaciÃ³n de Logros: "Felicidades a [Nombre] por llegar a 3000 IO."

Instrucciones para la IA (Prompt TÃ©cnico)
Si vas a pedirle esto a Replit o a un desarrollador, dale este resumen:

Project Specification: Create a Full-Stack Web Application for World of Warcraft Guild Management.

Stack:

Backend: FastAPI (Python) with PostgreSQL and SQLAlchemy.

Frontend: React (Next.js) with Tailwind CSS and Recharts.

Workers: Celery + Redis for background API fetching.

Core Features:

API Endpoint /upload: Accepts a compressed JSON payload from a local Python uploader (parsing SavedVariables.lua). Needs API Key auth.

Data Logic: Implement a "Master Roster" logic. If a player is uploaded in the Lua snapshot, upsert into DB. If a player in DB is missing from the Lua snapshot for >X days, mark as inactive.

Background Jobs:

RaiderIOSync: Fetch M+ scores for all active players every hour via public API. Handle UTF-8 names and Realm slugs correctly.

WarcraftLogsSync: Fetch recent raid parses using WLogs API v2.

UI/UX: Dark-themed dashboard displaying Connectivity Heatmaps (Day/Hour), Roster Tables with sorting/filtering, and individual Player Profiles with historical graphs.

Constraint: The system must handle high concurrency of reads (public view) vs low concurrency of writes (uploader). Optimize DB queries.

Â¿Por quÃ© esta arquitectura es "Robusta"?
Escalabilidad: Si maÃ±ana tu guild crece a 5,000 personas o invitas a otras guilds a usar tu web, el sistema aguanta (PostgreSQL + Redis).

Seguridad: Nadie toca la base de datos directamente. Todo pasa por la API.

Persistencia: Si se te rompe la PC, los datos siguen en la nube.

AutomatizaciÃ³n: TÃº duermes, el servidor sigue actualizando los Scores de Raider.IO y los Logs de Raid.